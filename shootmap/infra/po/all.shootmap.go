// Code generated by "shoot map -path=../../domain/model -alias=domain -type=*"; DO NOT EDIT.

package po

import domain "shoot-examples/shootmap/domain/model"
import "gorm.io/gorm"

// ToDomain converts receiver to type domain.Order
func (o *Order) ToDomain() *domain.Order {
	if o == nil {
		return nil
	}
	order_ := new(domain.Order)
	order_.ID = o.ID
	order_.Amount = o.Amount
	order_.Status = o.Status
	order_.OrderTime = o.OrderTime
	o.writeDomain(order_)
	return order_
}

// FromDomain reads from type domain.Order, then writes back to receiver and returns it
func (o *Order) FromDomain(order_ *domain.Order) *Order {
	if order_ == nil {
		return o
	}
	if o == nil {
		o = new(Order)
	}
	o.ID = order_.ID
	o.Amount = order_.Amount
	o.Status = order_.Status
	o.OrderTime = order_.OrderTime
	o.readDomain(*order_)
	return o
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func (o Order) ShootMap() { /*noop*/ }

// ToDomain converts receiver to type domain.User
func (u *User) ToDomain() *domain.User {
	if u == nil {
		return nil
	}
	user_ := new(domain.User)
	if u.Model != nil {
		user_.ID = u.ID
	}
	user_.FirstName = u.FirstName
	user_.LastName = u.LastName
	user_.Email = u.Email
	if u.AddressList != nil {
		user_.AddressList = make([]*domain.UserAddress, len(u.AddressList))
		for _i, _x := range u.AddressList {
			user_.AddressList[_i] = _x.ToDomain()
		}
	}
	u.writeDomain(user_)
	return user_
}

// FromDomain reads from type domain.User, then writes back to receiver and returns it
func (u *User) FromDomain(user_ *domain.User) *User {
	if user_ == nil {
		return u
	}
	if u == nil {
		u = new(User)
	}
	if u.Model == nil {
		u.Model = new(gorm.Model)
	}
	u.ID = user_.ID
	u.FirstName = user_.FirstName
	u.LastName = user_.LastName
	u.Email = user_.Email
	if user_.AddressList != nil {
		u.AddressList = make([]*UserAddress, len(user_.AddressList))
		for _i, _x := range user_.AddressList {
			u.AddressList[_i] = new(UserAddress).FromDomain(_x)
		}
	}
	u.readDomain(*user_)
	return u
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func (u User) ShootMap() { /*noop*/ }

// ToDomain converts receiver to type domain.UserAddress
func (u *UserAddress) ToDomain() *domain.UserAddress {
	if u == nil {
		return nil
	}
	userAddress_ := new(domain.UserAddress)
	if u.Model != nil {
		userAddress_.ID = u.ID
	}
	userAddress_.City = u.City
	userAddress_.Street = u.Street
	userAddress_.Room = u.Room
	userAddress_.Tag = u.Tag
	userAddress_.IsDefault = u.IsDefault
	userAddress_.OwnerID = u.UserID
	u.writeDomain(userAddress_)
	return userAddress_
}

// FromDomain reads from type domain.UserAddress, then writes back to receiver and returns it
func (u *UserAddress) FromDomain(userAddress_ *domain.UserAddress) *UserAddress {
	if userAddress_ == nil {
		return u
	}
	if u == nil {
		u = new(UserAddress)
	}
	if u.Model == nil {
		u.Model = new(gorm.Model)
	}
	u.ID = userAddress_.ID
	u.City = userAddress_.City
	u.Street = userAddress_.Street
	u.Room = userAddress_.Room
	u.Tag = userAddress_.Tag
	u.IsDefault = userAddress_.IsDefault
	u.UserID = userAddress_.OwnerID
	u.readDomain(userAddress_)
	return u
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func (u UserAddress) ShootMap() { /*noop*/ }
